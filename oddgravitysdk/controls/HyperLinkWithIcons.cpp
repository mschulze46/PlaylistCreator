// HyperLink.cpp : implementation file
//

#include "stdafx.h"
#include "HyperLinkWithIcons.h"
#include "BufferDC.h"



// CHyperLinkWithIcons

IMPLEMENT_DYNAMIC(CHyperLinkWithIcons, CStatic)
CHyperLinkWithIcons::CHyperLinkWithIcons()
{
	Initialize();
}

CHyperLinkWithIcons::~CHyperLinkWithIcons()
{
	if (m_lpLinkText != NULL)
		delete [] m_lpLinkText;
	if (m_lpLinkUrl != NULL)
		delete [] m_lpLinkUrl;

	m_hReg  = NULL;
	m_hHand = NULL;

	m_hFont.DeleteObject();

	if (m_hIconUp != NULL)
	{
		DestroyIcon(m_hIconUp);
	}

	if (m_hIconHover != NULL)
	{
		DestroyIcon(m_hIconHover);
	}

	if (m_hIconDown != NULL)
	{
		DestroyIcon(m_hIconDown);
	}

	if (m_hIconDisabled != NULL)
	{
		DestroyIcon(m_hIconDisabled);
	}
}

void CHyperLinkWithIcons::Initialize() 
{
	m_lpLinkText = NULL;
	m_lpLinkUrl  = NULL;

    m_hFont.CreateFont(14, 0, 0, 0, FW_NORMAL, 0, 0, 0,
        ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
        DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Arial");

	m_bUnderlineAlways = FALSE;
	m_bIsLink          = TRUE;
	m_bLockInPosition  = FALSE;
	m_bMultiline       = FALSE;

	m_crLinkUp     = RGB(0,0,255);
	m_crLinkHover  = RGB(255,0,0);
	m_crLinkDown   = RGB(200,0,225);
	m_crBackGround = ::GetSysColor(COLOR_BTNFACE);

	m_crBorder     = RGB(0,0,0);
	m_nBorderSize  = 0;
	m_nBorderStyle = PS_SOLID;

	m_hReg  = NULL;
	m_hHand = ::LoadCursor(NULL, MAKEINTRESOURCE(32649));

	m_hIconUp		= NULL;
	m_hIconHover	= NULL;
	m_hIconDown		= NULL;
	m_hIconDisabled = NULL;
	m_uShowIcon		= SI_ICONUP_ON		 | SI_ICONUP_LEFT		|   //Default: icons on the left Up/Hover/Down/Disabled
					  SI_ICONHOVER_ON	 | SI_ICONHOVER_LEFT	| 
					  SI_ICONDOWN_ON	 | SI_ICONDOWN_LEFT     |
					  SI_ICONDISABLED_ON | SI_ICONDISABLED_LEFT;

	m_bAutoGenerateDisabled = FALSE;
	m_bAutoGenerated        = FALSE;

	m_pToolTip			= &m_ToolTip;

    m_dwStaticStyle = SS_LEFT;

	//Status and Mouse control variables
	m_bDisabled  = FALSE;

	m_bMouseIn   = FALSE;
	m_bMouseDown = FALSE;

	m_bMovingWindow = FALSE;

	CreatePalette();
}

BEGIN_MESSAGE_MAP(CHyperLinkWithIcons, CStatic)
	ON_WM_PAINT()
	ON_WM_MOUSEMOVE()
	ON_WM_TIMER()
	ON_MESSAGE(WM_MOUSELEAVE,OnMouseLeave)
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_CAPTURECHANGED()
	ON_WM_ENABLE()
END_MESSAGE_MAP()

//Functions
int CHyperLinkWithIcons::OpenUrl()
{
	if (m_lpLinkUrl != NULL && m_bIsLink)
        HINSTANCE result = ShellExecute(NULL, _T("open"), m_lpLinkUrl, NULL,NULL, SW_SHOWDEFAULT);
	else
		return -1;

	return 0;
}

//Public
TCHAR* CHyperLinkWithIcons::GetLinkText()
{
	if (m_lpLinkText == NULL)
		return NULL;

	size_t len = _tcslen(m_lpLinkText) + 1;

	TCHAR* lpRet = new TCHAR[len];
	_tcsncpy_s(lpRet,len,m_lpLinkText,len);
	return lpRet;
}

void CHyperLinkWithIcons::SetLinkText(TCHAR* lpText)
{
	if (m_lpLinkText != NULL)
	{
		delete [] m_lpLinkText;
	}

	if (lpText != NULL)
	{
		size_t len = _tcslen(lpText)+1;
		m_lpLinkText = new TCHAR[len];
		_tcsncpy_s(m_lpLinkText,len,lpText,len);
	}
	else
		m_lpLinkText = NULL;
}

TCHAR* CHyperLinkWithIcons::GetLinkUrl()
{
	if (m_lpLinkUrl == NULL)
		return NULL;

	size_t len = _tcslen(m_lpLinkUrl)+1;
	TCHAR* lpRet = new TCHAR[len];
	_tcsncpy_s(lpRet,len,m_lpLinkUrl,len);
	return lpRet;
}

void CHyperLinkWithIcons::SetLinkUrl(TCHAR* lpUrl)
{
	if (m_lpLinkUrl != NULL)
	{
		delete [] m_lpLinkUrl;
	}

	if (lpUrl != NULL)
	{
		size_t len = _tcslen(lpUrl)+1;
		m_lpLinkUrl = new TCHAR[len];
		_tcsncpy_s(m_lpLinkUrl,len,lpUrl,len);
	}
	else
		m_lpLinkUrl = NULL;

	m_pToolTip->UpdateTipText(m_lpLinkUrl,this);
}

void CHyperLinkWithIcons::LockInPosition( BOOL bLockInPosition /*= FALSE*/ )
{
	if (m_bLockInPosition != bLockInPosition)
	{
		m_bLockInPosition = bLockInPosition; 
	}
}

void CHyperLinkWithIcons::SetMultiline( BOOL bMultiline )
{
	if (m_bMultiline != bMultiline)
	{ 
		m_bMultiline = bMultiline;
	}
}

void CHyperLinkWithIcons::IsLink( BOOL bIsLink /*= TRUE*/ )
{
	if (m_bIsLink != bIsLink)
	{
		m_bIsLink = bIsLink; 
	}
}

void CHyperLinkWithIcons::UnderlineAlways( BOOL bUnderlineAlways /*= FALSE*/ )
{
	if (m_bUnderlineAlways != bUnderlineAlways)
	{ 
		m_bUnderlineAlways = bUnderlineAlways; 
	}
}

void CHyperLinkWithIcons::SetColors(COLORREF crLinkUp, COLORREF crLinkHover, COLORREF crLinkDown, COLORREF crBackGround /* = ::GetSysColor(COLOR_BTNFACE) */)
{
	m_crLinkUp     = crLinkUp;
	m_crLinkHover  = crLinkHover;
	m_crLinkDown   = crLinkDown;
	m_crBackGround = crBackGround;
}

void CHyperLinkWithIcons::SetBackgroundColor( COLORREF crBackGround /*= ::GetSysColor(COLOR_BTNFACE)*/ )
{
	m_crBackGround = crBackGround;
}

void CHyperLinkWithIcons::SetBorderColor( COLORREF crBorder /*= RGB(0,0,0)*/ )
{
	m_crBorder = crBorder;
}

void CHyperLinkWithIcons::SetBorderSize( int nSize )
{
	m_nBorderSize = nSize;
}

void CHyperLinkWithIcons::SetBorderStyle( int nStyle )
{
	m_nBorderStyle = nStyle;
}

void CHyperLinkWithIcons::SetIcons(HICON hIconUp, HICON hIconHover, HICON hIconDown, UINT uShowIcons, HICON hIconDisabled /*= NULL*/)
{
	if (m_hIconUp == NULL || hIconUp != NULL)
	{
		if (m_hIconUp != NULL)
		{
			DestroyIcon(m_hIconUp);
		}

		m_hIconUp    = hIconUp;
	}

	if (m_hIconHover == NULL || hIconHover != NULL)
	{
		if (m_hIconHover != NULL)
		{
			DestroyIcon(m_hIconHover);
		}

		m_hIconHover = hIconHover;
	}

	if (m_hIconDown == NULL || hIconDown != NULL)
	{
		if (m_hIconDown != NULL)
		{
			DestroyIcon(m_hIconDown);
		}

		m_hIconDown = hIconDown;
	}

	if (m_hIconDisabled == NULL || hIconDisabled != NULL)
	{
		if (m_hIconDisabled != NULL)
		{
			DestroyIcon(m_hIconDisabled);
		}

		m_hIconDisabled  = hIconDisabled;

		if (m_hIconDisabled != NULL)
		{
			m_bAutoGenerated = FALSE;
		}
	}

	m_uShowIcon  = uShowIcons;
}

void CHyperLinkWithIcons::SetIconUp( int nIconUp, int dx /*= 0*/, int dy /*= 0*/ )
{
	if (m_hIconUp != NULL)
	{
		DestroyIcon(m_hIconUp);
	}

	m_hIconUp = (HICON)::LoadImage(
		AfxFindResourceHandle(MAKEINTRESOURCE(nIconUp), RT_GROUP_ICON),
		MAKEINTRESOURCE(nIconUp), IMAGE_ICON, dx, dy, 0);

	if (m_bAutoGenerateDisabled && m_hIconDisabled != NULL)
	{
		DestroyIcon(m_hIconDisabled);

		m_hIconDisabled  = NULL;
		m_bAutoGenerated = FALSE;
	}
}

void CHyperLinkWithIcons::SetIconHover( int nIconHover, int dx /*= 0*/, int dy /*= 0*/ )
{
	if (m_hIconHover != NULL)
	{
		DestroyIcon(m_hIconHover);
	}

	m_hIconHover = (HICON)::LoadImage(
		AfxFindResourceHandle(MAKEINTRESOURCE(nIconHover), RT_GROUP_ICON),
		MAKEINTRESOURCE(nIconHover), IMAGE_ICON, dx, dy, 0);

	if (m_bAutoGenerateDisabled && m_hIconDisabled != NULL)
	{
		DestroyIcon(m_hIconDisabled);

		m_hIconDisabled  = NULL;
		m_bAutoGenerated = FALSE;
	}
}

void CHyperLinkWithIcons::SetIconDown( int nIconDown, int dx /*= 0*/, int dy /*= 0*/ )
{
	if (m_hIconDown != NULL)
	{
		DestroyIcon(m_hIconDown);
	}

	m_hIconDown = (HICON)::LoadImage(
		AfxFindResourceHandle(MAKEINTRESOURCE(nIconDown), RT_GROUP_ICON),
		MAKEINTRESOURCE(nIconDown), IMAGE_ICON, dx, dy, 0);

	if (m_bAutoGenerateDisabled && m_hIconDisabled != NULL)
	{
		DestroyIcon(m_hIconDisabled);

		m_hIconDisabled  = NULL;
		m_bAutoGenerated = FALSE;
	}
}

void CHyperLinkWithIcons::SetIconDisabled( int nIconDisabled, int dx /*= 0*/, int dy /*= 0*/ )
{
	if (m_hIconDisabled != NULL)
	{
		DestroyIcon(m_hIconDisabled);
	}

	m_hIconDisabled = (HICON)::LoadImage(
		AfxFindResourceHandle(MAKEINTRESOURCE(nIconDisabled), RT_GROUP_ICON),
		MAKEINTRESOURCE(nIconDisabled), IMAGE_ICON, dx, dy, 0);
}

void CHyperLinkWithIcons::SetShowIcons( UINT uShowIcons )
{
	m_uShowIcon = uShowIcons;
}

void CHyperLinkWithIcons::SetAutoGenerateDisabled( BOOL bAutoGenerate )
{
	if (m_bAutoGenerateDisabled != bAutoGenerate)
	{
		if (m_hIconDisabled != NULL)
		{
			DestroyIcon(m_hIconDisabled);
		}

		m_bAutoGenerateDisabled = bAutoGenerate;

		if (!m_bAutoGenerateDisabled && m_bAutoGenerated)
		{
			m_hIconDisabled  = NULL;
			m_bAutoGenerated = FALSE;
		}
	}
}

BOOL CHyperLinkWithIcons::SetFont(TCHAR* lpFaceName /* = "Arial" */, int nSize /* = 14 */, int nWeight /* = FW_NORMAL */, BOOL bItalic /* = FALSE */)
{
    m_hFont.DeleteObject();

	BOOL ret = m_hFont.CreateFont(nSize, 0, 0, 0, nWeight, (BYTE)bItalic, 0, 0,
		ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
		DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, lpFaceName);

	if (ret)
	{
		if (::IsWindow(m_hWnd))
		{
			CWnd::SetFont(&m_hFont);
		}
	}

	return ret;
}

BOOL CHyperLinkWithIcons::SetFont( LPLOGFONT lpFont )
{
	m_hFont.DeleteObject();

	BOOL ret = m_hFont.CreateFontIndirect(lpFont);

	if (ret)
	{
		if (::IsWindow(m_hWnd))
		{
			CWnd::SetFont(&m_hFont);
		}
	}

	return ret;
}

BOOL CHyperLinkWithIcons::SetFont(HFONT hFont)
{
    m_hFont.DeleteObject();

    m_hFont.m_hObject = hFont;
    BOOL ret = (m_hFont.m_hObject != NULL) ? TRUE : FALSE;

    if (ret)
	{
		if (::IsWindow(m_hWnd))
		{
            CWnd::SetFont(&m_hFont);
		}
	}

	return ret;
}

void CHyperLinkWithIcons::Disable( BOOL bDisable /*= FALSE*/ )
{
	if (::IsWindow(this->GetSafeHwnd()))
	{
		EnableWindow(!bDisable);
	}
}

CToolTipCtrl* CHyperLinkWithIcons::GetTooltip()
{
	return m_pToolTip;
}

void CHyperLinkWithIcons::SetTooltip( CToolTipCtrl* pToolTip )
{
	if (pToolTip != NULL)
	{
		m_pToolTip = pToolTip;
	}
	else
	{
		m_pToolTip = &m_ToolTip;
	}

	CToolInfo toolInfo;
	toolInfo.cbSize    = sizeof(CToolInfo);
	toolInfo.szText[0] = (TCHAR)0;

	if (GetSafeHwnd() != NULL)
	{
		if (!m_pToolTip->GetToolInfo(toolInfo, this) ||
			(toolInfo.hwnd == NULL || ((toolInfo.uFlags & TTF_IDISHWND) == TTF_IDISHWND && toolInfo.uId == NULL)))
		{
			if (!::IsWindow(m_pToolTip->GetSafeHwnd()))
			{
				m_pToolTip->Create(this);
			}

			m_pToolTip->AddTool(this);
			m_pToolTip->UpdateTipText(m_lpLinkUrl,this);
		}
	}
}

void CHyperLinkWithIcons::SetTooltipText(TCHAR* lpTooltipText)
{
    if(m_pToolTip == NULL)
    {
        ASSERT(0); // error: no tooltip control available
        return;
    }

    m_pToolTip->UpdateTipText(lpTooltipText, this);
}

void CHyperLinkWithIcons::ActivateTooltip(BOOL bActivate)
{
    if(m_pToolTip == NULL)
    {
        ASSERT(0); // error: no tooltip control available
        return;
    }

    m_pToolTip->Activate(bActivate);
}

// CHyperLinkWithIcons message handlers

void CHyperLinkWithIcons::OnPaint()
{
	if (m_bMovingWindow)
	{
		return;
	}

	CBufferDC dc(this); // device context for painting

	dc.SaveDC();

	dc.SetMapMode(MM_TEXT);

	dc.SetBkMode(TRANSPARENT);

	dc.SelectObject(m_hFont);

	dc.SetBkColor(m_crBackGround);

	CRect rc;
    GetClientRect(&rc);
	CBrush cb;
	cb.CreateSolidBrush(m_crBackGround);
	dc.SelectObject(&cb);

	CBrush cb2;
	cb2.CreateSysColorBrush(COLOR_BTNFACE);
	dc.FillRect(&rc,&cb2);
	cb2.DeleteObject();

    BOOL bWndTxt = FALSE;
	if (m_lpLinkText == NULL)
	{
		bWndTxt = TRUE;
		int nlen = GetWindowTextLength();
		m_lpLinkText = new TCHAR[nlen+1];
		m_lpLinkText[nlen] = (TCHAR)0;
		GetWindowText(m_lpLinkText,nlen+1);
	}

	GetWindowRect(rc);
	GetParent()->ScreenToClient(&rc);

	SIZE iconSz    = GetFirstIcon();
	SIZE iconSpace = { 0 };
	iconSpace.cx   = iconSz.cx;
	iconSpace.cy   = iconSz.cy;

	if (m_bMouseIn)
	{
		int i = 0;
		i++;
	}

	if (m_bLockInPosition)
	{
		iconSpace = GetBiggestIcon();
	}

	CSize sz = dc.GetTextExtent(m_lpLinkText,(int)_tcslen(m_lpLinkText));

	int x = rc.left;
	int y = sz.cy + 2;

	int* nlOff = NULL;
	int* nlXl  = NULL;
	int  nlXlM = sz.cx;
	int  nlc   = 0;
	size_t len = _tcslen(m_lpLinkText);

	if (m_bMultiline)
	{
		while (len > 0 && m_lpLinkText[len-1] == _T('\n'))
		{
			len--;
		}

		if (len > 0)
		{
			while (len--)
			{
				if (m_lpLinkText[len] == _T('\n'))
				{
					nlc++;
				}
			}
		}

		if (nlc > 0)
		{
			nlc++;
			len      = _tcslen(m_lpLinkText);
			nlOff    = new int[nlc];
			nlXl     = new int[nlc];
			nlXlM    = 0;
			int nlc2 = nlc;

			while (len > 0 && m_lpLinkText[len-1] == _T('\n'))
			{
				len--;
			}

			if (len > 0)
			{
				size_t len2 = len;

				nlOff[--nlc2] = (int)len;

				while (len--)
				{
					if (m_lpLinkText[len] == _T('\n'))
					{
						nlXl[nlc2] = dc.GetTextExtent(&m_lpLinkText[len+1],(int)(len2 - len - 1)).cx;
						nlXlM = nlXl[nlc2] > nlXlM ? nlXl[nlc2] : nlXlM;
						len2 = len;

						y += sz.cy + 2;

						nlOff[--nlc2] = (int)len;
					}
				}

				if (len == -1)
				{
					nlXl[0] = dc.GetTextExtent(m_lpLinkText,(int)(len2)).cx;
					nlXlM = nlXl[0] > nlXlM ? nlXl[0] : nlXlM;
					len2 = len;
				}
			}
		}
	}
	
	if (nlc == 0 && len > 0)
	{
		len = _tcslen(m_lpLinkText);

		while (len > 0 && m_lpLinkText[len-1] == _T('\n'))
		{
			len--;
		}

		if (len > 0)
		{
			if (nlOff != NULL)
			{
				delete [] nlOff;
			}

			nlc      = 1;
			nlOff    = new int[nlc];
			nlXl     = new int[nlc];
			nlOff[0] = (int)len;
			nlXl[0]  = nlXlM;
		}
	}

	y += nlc;

	if (y < iconSpace.cy + 2)
	{
		y = iconSpace.cy + 2;
	}

	y += (m_nBorderSize * 2);

	y = rc.Height() - y;
	rc.bottom = rc.bottom - (y);

	x += (1 + nlXlM + (m_nBorderSize * 2) + 2);

	if ((!m_bDisabled &&
		  ((m_uShowIcon & SI_ICONUP_LEFT && !m_bMouseIn)     || 
		  (m_uShowIcon & SI_ICONHOVER_LEFT && m_bMouseIn && !m_bMouseDown)    || 
		  (m_uShowIcon & SI_ICONDOWN_LEFT && m_bMouseDown && m_bMouseIn))   
		) || 
		(m_uShowIcon & SI_ICONDISABLED_LEFT && m_bDisabled)  || 
		m_bLockInPosition)
	{
		x = x + iconSpace.cx + 3;
	}

	if ((!m_bDisabled &&
		  ((m_uShowIcon & SI_ICONUP_RIGHT && !m_bMouseIn)  || 
		  (m_uShowIcon & SI_ICONHOVER_RIGHT && m_bMouseIn && !m_bMouseDown)  || 
		  (m_uShowIcon & SI_ICONDOWN_RIGHT && m_bMouseDown && m_bMouseIn)) 
		) || 
		(m_uShowIcon & SI_ICONDISABLED_RIGHT && m_bDisabled) || 
		m_bLockInPosition)
	{
		x = x + 2 + iconSpace.cx + 1;
	}

	rc.right = x;

	m_bMovingWindow = TRUE;

	MoveWindow(rc.left,rc.top,rc.Width(),rc.Height(),FALSE);

	m_bMovingWindow = FALSE;

	GetClientRect(rc);

	dc.SetBoundsRect(&rc, DCB_DISABLE);

	dc.FillRect(&rc,&cb);


    //////////////////////////////////////////////////////
	// draw border

    if (m_nBorderSize > 0)
	{
		CRect brect = rc;
		CPen pen, *pOldPen;

		if (!m_bDisabled)
		{
			pen.CreatePen(m_nBorderStyle, m_nBorderSize, m_crBorder);
		}
		else
		{
			pen.CreatePen(m_nBorderStyle, m_nBorderSize, ::GetSysColor(COLOR_BTNSHADOW));
		}

		pOldPen = dc.SelectObject(&pen);

		int bspacer = (m_nBorderSize - (m_nBorderSize % 2)) / 2;

		brect.DeflateRect(bspacer, bspacer);

		if (m_nBorderSize % 2 == 0)
		{
			brect.right++;
			brect.bottom++;
		}

		dc.Rectangle(&brect);

		dc.SelectObject(pOldPen);
	}


    //////////////////////////////////////////////////////
	// draw icons

	CPen penUnderline;

    int yTxt = ((sz.cy * nlc) + (nlc * 3) - (nlc - 1));
	y = rc.Height() - iconSz.cy;
	y = (y - (y % 2)) / 2;

	x = 1 + m_nBorderSize;

	if (m_bLockInPosition)
	{
		x += ((iconSpace.cx - iconSz.cx) / 2);
	}
 
	if (m_bDisabled) // state: disabled
	{
		if (m_hIconDisabled != NULL)
		{
			if ((m_uShowIcon & SI_ICONDISABLED_ON && m_uShowIcon & SI_ICONDISABLED_LEFT))
			{
				DrawIconEx(dc.m_hDC,x,y,m_hIconDisabled,iconSz.cx,iconSz.cy,0,NULL,DI_IMAGE | DI_MASK);

				x = iconSpace.cx + 4 + m_nBorderSize;

				if (m_bLockInPosition)
				{
					x += ((iconSpace.cx - iconSz.cx) / 2);
				}
			}
			else if (m_bLockInPosition)
			{
				x = iconSpace.cx + 4 + m_nBorderSize;
				x += ((iconSpace.cx - iconSz.cx) / 2);
			}

			if ((m_uShowIcon & SI_ICONDISABLED_ON && m_uShowIcon & SI_ICONDISABLED_RIGHT))
			{
				DrawIconEx(dc.m_hDC,x + nlXlM + 3,y,m_hIconDisabled,iconSz.cx,iconSz.cy,0,NULL,DI_IMAGE | DI_MASK);
			}
		}

        // prepare for next drawing step
		dc.SetTextColor(::GetSysColor(COLOR_BTNSHADOW));
	}
	else if (!m_bDisabled && m_bMouseIn && !m_bMouseDown) // state: hovered
	{
		if ((m_uShowIcon & SI_ICONHOVER_ON && m_uShowIcon & SI_ICONHOVER_LEFT) && m_hIconHover != NULL)
		{
			DrawIconEx(dc.m_hDC,x,y,m_hIconHover,iconSz.cx,iconSz.cy,0,NULL,DI_IMAGE | DI_MASK);

			x = iconSpace.cx + 4 + m_nBorderSize;

			if (m_bLockInPosition)
			{
				x += ((iconSpace.cx - iconSz.cx) / 2);
			}
		}
		else if (m_bLockInPosition)
		{
			x = iconSpace.cx + 4 + m_nBorderSize;
			x += ((iconSpace.cx - iconSz.cx) / 2);
		}

		if ((m_uShowIcon & SI_ICONHOVER_ON && m_uShowIcon & SI_ICONHOVER_RIGHT) && m_hIconHover != NULL)
		{
			DrawIconEx(dc.m_hDC,x + nlXlM + 3,y,m_hIconHover,iconSz.cx,iconSz.cy,0,NULL,DI_IMAGE | DI_MASK);
		}

        // prepare for next drawing step
		penUnderline.CreatePen(PS_SOLID, 1, m_crLinkHover);
		dc.SetTextColor(m_crLinkHover);
	}
	else if (!m_bDisabled && m_bMouseIn && m_bMouseDown) // state: pressed
	{
		if ((m_uShowIcon & SI_ICONDOWN_ON && m_uShowIcon & SI_ICONDOWN_LEFT) && m_hIconDown != NULL)
		{
			DrawIconEx(dc.m_hDC,x,y,m_hIconDown,iconSz.cx,iconSz.cy,0,NULL,DI_IMAGE | DI_MASK);

			x = iconSpace.cx + 4 + m_nBorderSize;

			if (m_bLockInPosition)
			{
				x += ((iconSpace.cx - iconSz.cx) / 2);
			}
		}
		else if (m_bLockInPosition)
		{
			x = iconSpace.cx + 4 + m_nBorderSize;
			x += ((iconSpace.cx - iconSz.cx) / 2);
		}

		if ((m_uShowIcon & SI_ICONDOWN_ON && m_uShowIcon & SI_ICONDOWN_RIGHT) && m_hIconDown != NULL)
		{
			DrawIconEx(dc.m_hDC,x + nlXlM + 3,y,m_hIconDown,iconSz.cx,iconSz.cy,0,NULL,DI_IMAGE | DI_MASK);
		}

        // prepare for next drawing step
		penUnderline.CreatePen(PS_SOLID, 1, m_crLinkDown);
		dc.SetTextColor(m_crLinkDown);
	}
	else if (!m_bDisabled && !m_bMouseIn) // state: normal
	{
		if ((m_uShowIcon & SI_ICONUP_ON && m_uShowIcon & SI_ICONUP_LEFT) && m_hIconUp != NULL)
		{
			DrawIconEx(dc.m_hDC,x,y,m_hIconUp,iconSz.cx,iconSz.cy,0,NULL,DI_IMAGE | DI_MASK);

			x = iconSpace.cx + 4 + m_nBorderSize;

			if (m_bLockInPosition)
			{
				x += ((iconSpace.cx - iconSz.cx) / 2);
			}
		}
		else if (m_bLockInPosition)
		{
			x = iconSpace.cx + 4 + m_nBorderSize;
			x += ((iconSpace.cx - iconSz.cx) / 2);
		}

		if ((m_uShowIcon & SI_ICONUP_ON && m_uShowIcon & SI_ICONUP_RIGHT) && m_hIconUp != NULL)
		{
			DrawIconEx(dc.m_hDC,x + nlXlM + 3,y,m_hIconUp,iconSz.cx,iconSz.cy,0,NULL,DI_IMAGE | DI_MASK);
		}

        // prepare for next drawing step
        penUnderline.CreatePen(PS_SOLID, 1, (m_bUnderlineAlways) ? m_crLinkUp : m_crBackGround);
		dc.SetTextColor(m_crLinkUp);
	}

	if (m_bLockInPosition)
	{
		x = iconSpace.cx + 4 + m_nBorderSize;
	}

	y = rc.Height() - ((sz.cy * nlc) + (nlc * 3) - (nlc - 1));
	if (y < 0)
	{
		y = 0;
	}
	y = (y - (y % 2)) / 2;


    //////////////////////////////////////////////////////
    // draw text

    if (nlc > 0)
    {
        dc.SelectObject(penUnderline);

        switch(m_dwStaticStyle)
        {
            case SS_RIGHT: ASSERT(0); // warning: not implemented yet (falling back to SS_LEFT)
            default:
            case SS_LEFT:
            {
                dc.TextOut(x,y,m_lpLinkText,(int)nlOff[0]);
                dc.MoveTo(x,y+sz.cy);
                dc.LineTo(x+nlXl[0],y+sz.cy);

                for (int i = 1; i < nlc; i++)
                {
                    y += sz.cy + 2;
                    dc.TextOut(x,y,&m_lpLinkText[nlOff[i-1]+1],(int)(nlOff[i] - nlOff[i-1] - 1));
                    dc.MoveTo(x,y+sz.cy);
                    dc.LineTo(x+nlXl[i],y+sz.cy);
                }
            }
            break;

            case SS_CENTER:
            {
                // set text alignment
                dc.SetTextAlign(dc.GetTextAlign() | TA_CENTER | TA_TOP);

                // calculate center position of longest line
                int centerPos = 0;
                for (int i = 0; i < nlc; i++)
                {
                    centerPos = max(nlXl[i] / 2, centerPos);
                }

                // draw first line of text
                dc.TextOut(x + centerPos, y, m_lpLinkText, (int)nlOff[0]);
                dc.MoveTo(x + centerPos - (nlXl[0] / 2) - 1, y + sz.cy);
                dc.LineTo(x + centerPos + (nlXl[0] / 2) + 1, y + sz.cy);

                // draw all remaining lines of text
                for (int i = 1; i < nlc; i++)
                {
                    // update vertical position
                    y += sz.cy + 2;

                    // draw text
                    dc.TextOut(x + centerPos, y, &m_lpLinkText[nlOff[i-1] + 1], (int)(nlOff[i] - nlOff[i-1] - 1));
                    dc.MoveTo(x + centerPos - (nlXl[i] / 2) - 1, y + sz.cy);
                    dc.LineTo(x + centerPos + (nlXl[i] / 2) + 1, y + sz.cy);
                }
            }
            break;
        }
    }


    //////////////////////////////////////////////////////
    // cleanup

    if (bWndTxt)
	{
		delete [] m_lpLinkText;
		m_lpLinkText = NULL;
	}

	if (nlOff != NULL)
	{
		delete [] nlOff;
	}

	if (nlXl != NULL)
	{
		delete [] nlXl;
	}

	dc.RestoreDC(-1);
}


SIZE CHyperLinkWithIcons::GetBiggestIcon()
{
	HICON    hIco   = NULL;
	ICONINFO icInfo = { 0 };
	SIZE     iconSz = { 0 };
	SIZE     tempSz = { 0 };

	hIco = m_hIconUp;

	if (hIco != NULL)
	{
        iconSz = GetIconSize(hIco);
	}

	hIco = m_hIconHover;

	if (hIco != NULL)
	{
        tempSz = GetIconSize(hIco);

        if (tempSz.cx > iconSz.cx)
		{
			iconSz.cx = tempSz.cx;
			iconSz.cy = tempSz.cy;
		}
	}

	hIco = m_hIconDown;

	if (hIco != NULL)
	{
        tempSz = GetIconSize(hIco);

        if (tempSz.cx > iconSz.cx)
		{
			iconSz.cx = tempSz.cx;
			iconSz.cy = tempSz.cy;
		}
	}

	hIco = m_hIconDisabled;

	if (hIco != NULL)
	{
        tempSz = GetIconSize(hIco);

        if (tempSz.cx > iconSz.cx)
		{
			iconSz.cx = tempSz.cx;
			iconSz.cy = tempSz.cy;
		}
	}

	return iconSz;
}

SIZE CHyperLinkWithIcons::GetFirstIcon()
{
	HICON    hIco   = NULL;
	ICONINFO icInfo = { 0 };
	SIZE     iconSz = { 0 };

	if ((!m_bDisabled &&
		  ((m_uShowIcon & SI_ICONUP_LEFT && !m_bMouseIn)      || 
		  (m_uShowIcon & SI_ICONHOVER_LEFT && m_bMouseIn && !m_bMouseDown)     || 
		  (m_uShowIcon & SI_ICONDOWN_LEFT && m_bMouseDown && m_bMouseIn)    || 
		  (m_uShowIcon & SI_ICONUP_RIGHT && !m_bMouseIn)      || 
		  (m_uShowIcon & SI_ICONHOVER_RIGHT && m_bMouseIn && !m_bMouseDown)    || 
		  (m_uShowIcon & SI_ICONDOWN_RIGHT && m_bMouseDown && m_bMouseIn))
		) ||
		(m_uShowIcon & SI_ICONDISABLED_LEFT && m_bDisabled) || 
		(m_uShowIcon & SI_ICONDISABLED_RIGHT && m_bDisabled))
	{
		if (m_bDisabled)
		{
			if (m_hIconDisabled == NULL && m_bAutoGenerateDisabled)
			{
				HICON hico = m_hIconUp;

				if (hico == NULL)
				{
					hico = m_hIconHover;
				}

				if (hico == NULL)
				{
					hico = m_hIconDown;
				}

				if (hico != NULL)
				{
					m_hIconDisabled  = CreateGrayscaleIcon(hico);
					m_bAutoGenerated = TRUE;
				}
			}

			hIco = m_hIconDisabled;
		}
		else if (!m_bDisabled && m_bMouseIn && !m_bMouseDown)
		{
			hIco = m_hIconHover;
		}
		else if (!m_bDisabled && m_bMouseIn && m_bMouseDown)
		{
			hIco = m_hIconDown;
		}
		else if (!m_bDisabled && !m_bMouseIn)
		{
			hIco = m_hIconUp;
		}

		if (hIco != NULL)
		{
            iconSz = GetIconSize(hIco);
		}
	}

	return iconSz;
}

SIZE CHyperLinkWithIcons::GetIconSize(HICON hIcon)
{
    SIZE iconSize;
    iconSize.cx = 0;
    iconSize.cy = 0;

    if(hIcon == NULL)
    {
        ASSERT(0); // error: no icon passed
        return iconSize;
    }

    ICONINFO iconInfo;
    if (GetIconInfo(hIcon, &iconInfo))
    {
        CBitmap* pBitmap = CBitmap::FromHandle(iconInfo.hbmColor);
        if (pBitmap)
        {
            BITMAP bm;
            pBitmap->GetBitmap(&bm);
            iconSize.cx = bm.bmWidth;
            iconSize.cy = bm.bmHeight;
        }

        if (iconInfo.hbmColor)
        ::DeleteObject(iconInfo.hbmColor);
        if (iconInfo.hbmMask)
        ::DeleteObject(iconInfo.hbmMask);
    }

    return iconSize;
}

void CHyperLinkWithIcons::CreatePalette()
{
	for(int i = 0; i < 256; i++)
	{
		m_dwszGrayScalePalette[i] = RGB(255-i, 255-i, 255-i);
	}
}

HICON CHyperLinkWithIcons::CreateGrayscaleIcon( HICON hIcon)
{
	if (hIcon == NULL)
	{
		return NULL;
	}

	HDC hdc = ::GetDC(NULL);

	HICON      hGrayIcon      = NULL;
	ICONINFO   icInfo         = { 0 };
	ICONINFO   icGrayInfo     = { 0 };
	LPDWORD    lpBits         = NULL;
	LPBYTE     lpBitsPtr      = NULL;
	SIZE sz;
	DWORD c1 = 0;
	BITMAPINFO bmpInfo        = { 0 };
	bmpInfo.bmiHeader.biSize  = sizeof(BITMAPINFOHEADER);

	if (::GetIconInfo(hIcon, &icInfo))
	{
		if (GetDIBits(hdc, icInfo.hbmColor, 0, 0, NULL, &bmpInfo, DIB_RGB_COLORS) != 0)
		{
			bmpInfo.bmiHeader.biCompression = BI_RGB;

			sz.cx = bmpInfo.bmiHeader.biWidth;
			sz.cy = bmpInfo.bmiHeader.biHeight;
			c1 = sz.cx * sz.cy;

			lpBits = (LPDWORD)GlobalAlloc(GMEM_FIXED, (c1) * 4);

			if (lpBits && GetDIBits(hdc, icInfo.hbmColor, 0, sz.cy, lpBits, &bmpInfo, DIB_RGB_COLORS) != 0)
			{
				lpBitsPtr     = (LPBYTE)lpBits;
				UINT off      = 0;

				for (UINT i = 0; i < c1; i++)
				{
					off = (UINT)( 255 - (( lpBitsPtr[0] + lpBitsPtr[1] + lpBitsPtr[2] ) / 3) );

					if (lpBitsPtr[3] != 0 || off != 255)
					{
						if (off == 0)
						{
							off = 1;
						}

						lpBits[i] = m_dwszGrayScalePalette[off] | ( lpBitsPtr[3] << 24 );
					}

					lpBitsPtr += 4;
				}

				icGrayInfo.hbmColor = CreateCompatibleBitmap(hdc, sz.cx, sz.cy);

				if (icGrayInfo.hbmColor != NULL)
				{
					SetDIBits(hdc, icGrayInfo.hbmColor, 0, sz.cy, lpBits, &bmpInfo, DIB_RGB_COLORS);

					icGrayInfo.hbmMask = icInfo.hbmMask;
					icGrayInfo.fIcon   = TRUE;

					hGrayIcon = CreateIconIndirect(&icGrayInfo);

					::DeleteObject(icGrayInfo.hbmColor);
				}

				GlobalFree(lpBits);
				lpBits = NULL;
			}
		}

		::DeleteObject(icInfo.hbmColor);
		::DeleteObject(icInfo.hbmMask);
	}

	::ReleaseDC(NULL,hdc);

	return hGrayIcon;
}

void CHyperLinkWithIcons::OnMouseMove(UINT nFlags, CPoint point)
{
	if (!m_bDisabled)
	{
		ShowCursor(FALSE);
		m_hReg = ::SetCursor(m_hHand);
		ShowCursor(TRUE);
	}

	if (m_bMouseIn)
		return;

	TRACKMOUSEEVENT EventTrack;
	EventTrack.cbSize = sizeof(TRACKMOUSEEVENT);
	EventTrack.dwFlags = TME_LEAVE;
	EventTrack.dwHoverTime = 0;
	EventTrack.hwndTrack = m_hWnd;
	TrackMouseEvent(&EventTrack);

	m_bMouseIn = TRUE;

	if (nFlags & MK_LBUTTON)
		m_bMouseDown = TRUE;
	else
		m_bMouseDown = FALSE;

	Invalidate();
}

LRESULT CHyperLinkWithIcons::OnMouseLeave(WPARAM, LPARAM)
{
	m_pToolTip->Pop();

	TRACKMOUSEEVENT EventTrack;
	EventTrack.cbSize = sizeof(TRACKMOUSEEVENT);
	EventTrack.dwFlags = TME_CANCEL | TME_LEAVE;
	EventTrack.dwHoverTime = 0;
	EventTrack.hwndTrack = m_hWnd;
	TrackMouseEvent(&EventTrack);

	m_bMouseIn = FALSE;

	BOOL bRepaint = TRUE;
	RECT rect;
	POINT pt;

	GetClientRect(&rect);
	MapWindowPoints(NULL,(LPPOINT)&rect,2);
	GetCursorPos(&pt);

	if (PtInRect(&rect,pt) && (WindowFromPoint(pt) == this || WindowFromPoint(pt) == m_pToolTip))
	{
		bRepaint = FALSE;
		SetTimer(1001, 300, NULL);
	}

	if (!m_bDisabled)
	{
		ShowCursor(FALSE);
		::SetCursor(m_hReg);
		ShowCursor(TRUE);
	}

	if (bRepaint)
	{
		Invalidate();
	}

	return 0;
}

void CHyperLinkWithIcons::OnTimer( UINT_PTR nIDEvent )
{
	if (nIDEvent == 1001)
	{
		KillTimer(nIDEvent);

		if (m_bMouseDown)
		{
			return;
		}

		RECT rect;
		POINT pt;
		CWnd* wndInPt = NULL;

		GetClientRect(&rect);
		MapWindowPoints(NULL,(LPPOINT)&rect,2);
		GetCursorPos(&pt);

		if (!PtInRect(&rect,pt) || ((wndInPt = WindowFromPoint(pt)) != this && wndInPt != m_pToolTip))
		{
			m_bMouseIn = FALSE;
			Invalidate();
		}
	}
}

void CHyperLinkWithIcons::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (!m_bDisabled)
	{
		ShowCursor(FALSE);
		m_hReg = ::SetCursor(m_hHand);
		ShowCursor(TRUE);
	}

	m_bMouseDown = FALSE;

	POINT cPt;

	GetCursorPos(&cPt);

	if (cPt.x >= m_rcCapture.left &&
		cPt.x <= m_rcCapture.right &&
		cPt.y >= m_rcCapture.top &&
		cPt.y <= m_rcCapture.bottom)
	{
		m_bMouseIn = TRUE;
	}
	else
	{
		m_bMouseIn = FALSE;
	}

	ReleaseCapture();

	Invalidate();

	if (!m_bDisabled && m_bMouseIn)
	{
		OpenUrl();

		if (!m_bIsLink || (GetStyle() & SS_NOTIFY))
		{
			CWnd* pParent = GetParent();

			if (pParent != NULL)
			{
				WORD wID = GetDlgCtrlID();

				if (wID)
				{
					pParent->SendMessage(WM_COMMAND, MAKEWPARAM(wID,STN_CLICKED),(LPARAM)m_hWnd);
				}
			}
		}
	}
}

void CHyperLinkWithIcons::OnLButtonDown(UINT nFlags, CPoint point)
{
	if (!m_bDisabled)
	{
		ShowCursor(FALSE);
		m_hReg = ::SetCursor(m_hHand);
		ShowCursor(TRUE);
	}

	m_bMouseDown = TRUE;

	SetCapture();

	Invalidate();

	GetClientRect(&m_rcCapture);
	ClientToScreen(&m_rcCapture);
}

void CHyperLinkWithIcons::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	if (!m_bDisabled && (!m_bIsLink || GetStyle() & SS_NOTIFY))
	{
		CStatic::OnLButtonDblClk(nFlags,point);
	}

	if (!m_bDisabled)
	{
		ShowCursor(FALSE);
		m_hReg = ::SetCursor(m_hHand);
		ShowCursor(TRUE);
	}

	m_bMouseDown = TRUE;

	SetCapture();

	Invalidate();

	GetClientRect(&m_rcCapture);
	ClientToScreen(&m_rcCapture);
}

void CHyperLinkWithIcons::PreSubclassWindow()
{
	CStatic::PreSubclassWindow();

    // remember the styles of the underlying CStatic
    m_dwStaticStyle = GetStyle() & SS_TYPEMASK;

	ModifyStyle(SS_BITMAP | SS_ICON, SS_OWNERDRAW | SS_NOTIFY);

	if (GetStyle() & WS_DISABLED)
	{
		m_bDisabled = TRUE;
	}

	m_ToolTip.Create(this);
	m_ToolTip.AddTool(this);
	m_ToolTip.SetDelayTime(TTDT_INITIAL, 1200);
	m_ToolTip.SetDelayTime(TTDT_AUTOPOP, 1600);
}

BOOL CHyperLinkWithIcons::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_MOUSEMOVE   || 
		pMsg->message == WM_LBUTTONDOWN || 
		pMsg->message == WM_LBUTTONUP   ||
		pMsg->message == WM_MOUSELEAVE)
	{
		if (m_pToolTip->m_hWnd)
		{
			m_pToolTip->RelayEvent(pMsg);
		}
	}

	return CStatic::PreTranslateMessage(pMsg);
}

void CHyperLinkWithIcons::OnCaptureChanged( CWnd* pWnd )
{
}

void CHyperLinkWithIcons::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct )
{
}

LRESULT CHyperLinkWithIcons::WindowProc( UINT message, WPARAM wParam, LPARAM lParam )
{
    switch(message)
    {
        case WM_ENABLE:
        {
		    m_bDisabled = !IsWindowEnabled();
            return TRUE;
        }
        break;

        case WM_SETFONT:
        {
            m_hFont.DeleteObject();
            m_hFont.m_hObject = (HFONT)wParam;
        }
        break;

        default:
            break;
    }

    return CWnd::WindowProc(message, wParam, lParam);
}
